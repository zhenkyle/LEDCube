/*
 * Code to controll an 8x8x8 ledcube using avr
 * http://www.instructables.com/id/Led-Cube-8x8x8/
 * See lisence.txt for lisence.
 */
#include "main.h"
#include "effect.h"
#include "launch_effect.h"
#include "draw.h"
#include "spi.h"
#include "usart.h"

// Main loop
// the AVR enters this function at boot time
int main (void)
{
	// Inits LEDS
	initLEDs();
	// Inits Buttons
	initButtons();
	// Inits Timer2
	initTimer2();
  	// Inits SPI 
  	initSPI();
	// Initial Latch
	LATCH_DDR |= (1 << LATCH);
	// Inits USART
  	initUSART();
    // This variable specifies which layer is currently being drawn by the
	// cube interrupt routine. We assign a value to it to make sure it's not >7.
	current_layer = 0;	

	int i;
	
	// Boot wait
	// This function serves 3 purposes
	// 1) We delay starting up any interrupts, as drawing the cube causes a lot
	//    noise that can confuse the ISP programmer.
	// 2) Listen for button press. One button means go into uart mode,
	//    The other means go into autonomous mode and start doing stuff.
	// 3) Random seed. The bootwait function counts forever from 0 to 255.
	//    Whenever you press the button, this counter stops, and the number it
	//    stopped at is used as a random seed. This ensures true randomness at
	//    every boot. Without this (or some similar process) the cube would
	//    produce the same "random" sequence every time
	i = bootwait();

	// Turn off LEDs
	LED_PORT &= ~(1 << LED_RED);
	LED_PORT &= ~(1 << LED_GREEN);

	// Enable interrupts
	// This starts the routine that draws the cube content
	sei();

	// Result for bootwait() is 2:
	// Go to uart mode. this function loops forever.
	if (i == 2)
	{
		uart();
	}

	// Result of bootwait() is something other than 2:
	// Do awesome effects. Loop forever.
	while (1)
	{
		// Show the effects in a predefined order
		for (i=0; i < EFFECTS_TOTAL; i++)
		{
			LED_PORT ^= (1 << LED_PGM);
			launch_effect(i);
		}

		
		// Show the effects in a random order.
		// Comment the two lines above and uncomment this
		// if you want the effects in a random order.
		//launch_effect(rand()%EFFECTS_TOTAL);
	}

}

/*
 * Multiplexer/framebuffer routine
 * This function is called by an interrupt generated by timer 2.
 * Every time it runs, it does the following:
 * 1) Disable the output for the multiplexer array.
 * 2) Turn of all layers.
 * 3) Load the current layer from the cube buffer onto the
 *    multiplexer array.
 * 4) Enable output from the multiplexer array.
 * 5) Turn on the current layer.
 * 6) Increment the current_layer variable, so the next layer is
 *    drawn the next time this function runs.
*/

ISR(TIMER2_COMPA_vect)
{
	int i;

	// take the Latch low so
	// the LEDs don't change while you're sending in bits:
	LATCH_PORT &= ~ (1 << LATCH);

	// shift out the bits:
	SPI_tradeByte(1 << current_layer);

	for (i=0; i < 8; i++)
		SPI_tradeByte(cube[current_layer][i]);

	//take the latch pin high so the LEDs will light up:
	LATCH_PORT |= (1 << LATCH);

	current_layer++;
	if (current_layer == 8)
		current_layer = 0;
}

void initLEDs()
{
	LED_DDR |= (1 << LED_GREEN);
	LED_DDR |= (1 << LED_RED);
	LED_DDR |= (1 << LED_PGM); // for debug
}

void initButtons()
{
	BUTTON_DDR &= ~(1 << UART_BTN);  // makes double-sure we're in input mode
	BUTTON_PORT |= (1 << UART_BTN);  // enables pull-up resistor

	BUTTON_DDR &= ~(1 << MAIN_BTN);  // makes double-sure we're in input mode
	BUTTON_PORT |= (1 << MAIN_BTN);  // enables pull-up resistor
}

void initTimer2()
{
	// Timer 2
	// Frame buffer interrupt = clock / prescaler / (OCR2A + 1)
	// 16000000/256/11 = 563 interrupts per second
	// frame per second = Frame buffer interrup / 8
	// 563/8 = 70.38 frames per second
  
    // Reset any PWM configuration that the arduino may have set up automagically!
	TCCR2A = 0x00;
	TCCR2B = 0x00;

	TCCR2A |= (0x01 << WGM21); // CTC mode. clear counter on TCNT2 == OCR2A
	OCR2A = 10; // Interrupt every 25600th cpu cycle ( prescaler * OCR2A)
	TCNT2 = 0x00; // start counting at 0
	TCCR2B |= (0x01 << CS22) | (0x01 << CS21); // Start the clock with a 256 prescaler

	TIMSK2 |= (0x01 << OCIE2A);
}

// Boot wait function
// This function does 3 things:
// 1) Delay startup of interrupt. I've had some problems with in circuit
//    serial programming when the cube was running. I guess switching all
//    those LEDs on and off generates some noise.
// 2) Set a random random seed based on the delay between boot time and
//    the time you press a button.
// 3) Select mode of operation, autonomous or uart controlled.
unsigned int bootwait (void)
{
	// All the LED_PORT... code blinks the red and green status LEDs.

	unsigned int x = 0;
	LED_PORT |= (1 << LED_GREEN);
	while (1)
	{
        x++; // increment x by one.
		srand(x); // use counter x as random seed
		
		_delay_ms(1000);
		LED_PORT &= ~ (1 << LED_GREEN); // green off, red on
		LED_PORT |= (1 << LED_RED);
		
		// Listen for button presses and return with the
		// apropriate number.
		if (!(BUTTON_PIN & (1 << UART_BTN)))
			return 2;

		if (!(BUTTON_PIN & (1 << MAIN_BTN)))
			return 1;
		
		_delay_ms(1000);
		LED_PORT &= ~ (1 << LED_RED); // red off, green on
		LED_PORT |= (1 << LED_GREEN);
		
		// Same as above. I do it twise because there are two delays
		// in this loop, used for the red and green led blinking..
		if (!(BUTTON_PIN & (1 << UART_BTN)))
			return 2;

		if (!(BUTTON_PIN & (1 << MAIN_BTN)))
			return 1;
	}
}

// Take input from a computer and load it onto the cube buffer
void uart(void)
{
	int tempval;
	int x = 0;
	int y = 0;
    int escape = 0;
	
	while (1)
	{
		// Switch state on red LED for debugging
		// Should switch state every time the code
		// is waiting for a byte to be received.
		LED_PORT ^= (1 << LED_RED);

		// Wait until a byte has been received
		while ( !(UCSR0A & (1<<RXC0)) );

		// Load the received byte from uart into a buffer.
		tempval = UDR0;

		// Uncommet this to echo data back to the computer
		// for debugging purposes.
		//UDR0 = tempval;

		// Every time the cube receives a 0xff byte,
		// it goes into sync escape mode.
		// if a 0x00 byte is then received, the x and y counters
		// are reset to 0. This way the x and y counters are
		// always the same on the computer and in the cube.
		// To send an 0xff byte, you have to send it twice!

		// Go into sync escape mode
		if (tempval == 0xff)
		{
			// Wait for the next byte
			 while ( !(UCSR0A & (1<<RXC0)) );
			 // Get the next byte
			 tempval = UDR0;

			 // Sync signal is received.
			 // Reset x and y counters to 0.
			 if (tempval == 0x00)
			 {
				x = 0;
				y = 0;
                escape = 1;
			 }
			 // if no 0x00 byte is received, proceed with
			 // the byte we just received.
		}

        if (escape == 0)
        {
		// Load data into the current position in the buffer
		fb[x][y] = tempval;

    		// Check if we have reached the limits of the buffer array.
    		if (y == 7)
    		{
    			if (x == 7)
    			{
    				// All data is loaded. Reset both counters
    				y = 0;
    				x = 0;
                    // Copy the data onto the cube.
    				tmp2cube();
    			} else
    			{
    				// A layer is loaded, reset y and increment x.
    				x++;
    				y = 0;
    			}
    		} else
    		{
    			// We are in the middle of loading a layer. increment y.
    			y++;
    		}
	
	    } else
        {
            escape = 0;
        }
    }
}
